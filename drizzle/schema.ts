import { pgTable, unique, serial, text, integer, timestamp, jsonb, index, check, boolean, varchar } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"



export const teachers = pgTable("teachers", {
	id: serial().primaryKey().notNull(),
	name: text().notNull(),
	surname: text().notNull(),
	role: text().notNull(),
	email: text().notNull(),
	phone: text().notNull(),
	subjects: text().array().notNull(),
	experience: integer().notNull(),
	qualification: text().notNull(),
	staffId: integer("staff_id").notNull(),
	classRole: text("class_role"),
}, (table) => [
	unique("teachers_staff_id_unique").on(table.staffId),
]);

export const staffLeave = pgTable("staff_leave", {
	id: serial().primaryKey().notNull(),
	staffId: integer("staff_id").notNull(),
	leaveType: text("leave_type").notNull(),
	startDate: text("start_date").notNull(),
	endDate: text("end_date").notNull(),
	status: text().default('pending'),
	reason: text(),
	approvedBy: integer("approved_by"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const staffSalary = pgTable("staff_salary", {
	id: serial().primaryKey().notNull(),
	staffId: integer("staff_id").notNull(),
	baseSalary: integer("base_salary").notNull(),
	allowances: jsonb().default({}),
	deductions: jsonb().default({}),
	effectiveDate: text("effective_date").notNull(),
	paymentFrequency: text("payment_frequency").default('monthly'),
});

export const students = pgTable("students", {
	id: serial().primaryKey().notNull(),
	name: text().notNull(),
	surname: text().notNull(),
	phone: text(),
	address: text(),
	attendance: text(),
	class: text(),
	email: text(),
});

export const subjects = pgTable("subjects", {
	id: serial().primaryKey().notNull(),
	name: text().notNull(),
	className: text("class_name").notNull(),
	teacher: text().notNull(),
	teacherIds: integer("teacher_ids").array().notNull(),
	teacherNames: text("teacher_names").array().notNull(),
	schedule: text().notNull(),
	duration: text().notNull(),
	topics: text().array().notNull(),
	assessments: jsonb().default([]).notNull(),
	classSection: text("class_section").default('primary').notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_subjects_class_name_section").using("btree", table.className.asc().nullsLast().op("text_ops"), table.classSection.asc().nullsLast().op("text_ops")),
	index("idx_subjects_name").using("btree", table.name.asc().nullsLast().op("text_ops")),
	index("idx_subjects_teacher_names").using("gin", table.teacherNames.asc().nullsLast().op("array_ops")),
	index("idx_subjects_updated").using("btree", table.updatedAt.asc().nullsLast().op("timestamp_ops")),
	check("subjects_class_name_not_empty", sql`(class_name IS NOT NULL) AND (class_name <> ''::text)`),
	check("subjects_name_not_empty", sql`(name IS NOT NULL) AND (name <> ''::text)`),
	check("subjects_teacher_names_not_null", sql`teacher_names IS NOT NULL`),
]);

export const studentMedicalInfo = pgTable("student_medical_info", {
	id: integer().primaryKey().notNull(),
	idNumber: text("id_number").notNull(),
	familyDoctor: text("family_doctor"),
	doctorPhone: text("doctor_phone"),
	medicalConditions: text("medical_conditions").array(),
	medicalConditionsDetails: text("medical_conditions_details"),
	childhoodSicknesses: text("childhood_sicknesses"),
	lifeThreateningAllergies: text("life_threatening_allergies"),
	otherAllergies: text("other_allergies"),
	regularMedications: boolean("regular_medications"),
	regularMedicationsDetails: text("regular_medications_details"),
	majorOperations: text("major_operations"),
	behaviorProblems: text("behavior_problems"),
	speechHearingProblems: text("speech_hearing_problems"),
	birthComplications: text("birth_complications"),
	immunisationUpToDate: boolean("immunisation_up_to_date"),
	familyMedicalHistory: text("family_medical_history"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_student_medical_id").using("btree", table.id.asc().nullsLast().op("int4_ops")),
	index("idx_student_medical_id_number").using("btree", table.idNumber.asc().nullsLast().op("text_ops")),
	check("student_medical_id_required", sql`id IS NOT NULL`),
]);

export const subjectTeachers = pgTable("subject_teachers", {
	id: serial().primaryKey().notNull(),
	subjectId: integer("subject_id").notNull(),
	teacherId: integer("teacher_id").notNull(),
	teacherName: text("teacher_name").notNull(),
	isPrimary: boolean("is_primary").default(false),
});

export const classActivities = pgTable("class_activities", {
	id: serial().primaryKey().notNull(),
	title: text().notNull(),
	date: text().notNull(),
	className: text("class_name"),
});

export const classes = pgTable("classes", {
	id: serial().primaryKey().notNull(),
	className: text("class_name").notNull(),
	teachers: text().array().notNull(),
	subjects: text().array().notNull(),
	classSection: text("class_section").notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	classTeacher: text("class_teacher"),
}, (table) => [
	index("idx_classes_name_section").using("btree", table.className.asc().nullsLast().op("text_ops"), table.classSection.asc().nullsLast().op("text_ops")),
	index("idx_classes_section").using("btree", table.classSection.asc().nullsLast().op("text_ops")),
	index("idx_classes_updated").using("btree", table.updatedAt.asc().nullsLast().op("timestamp_ops")),
	unique("unique_class_name_section").on(table.className, table.classSection),
	check("classes_class_name_not_empty", sql`(class_name IS NOT NULL) AND (class_name <> ''::text)`),
	check("classes_teachers_not_null", sql`teachers IS NOT NULL`),
	check("classes_subjects_not_null", sql`subjects IS NOT NULL`),
]);

export const staff = pgTable("staff", {
	id: serial().primaryKey().notNull(),
	staffId: varchar("staff_id", { length: 20 }).notNull(),
	name: text().notNull(),
	surname: text().notNull(),
	email: text().notNull(),
	phone: text().notNull(),
	address: text(),
	dateOfBirth: text("date_of_birth"),
	gender: text(),
	emergencyContact: text("emergency_contact"),
	emergencyPhone: text("emergency_phone"),
	employmentType: text("employment_type").notNull(),
	position: text().notNull(),
	department: text().notNull(),
	hireDate: text("hire_date").notNull(),
	terminationDate: text("termination_date"),
	employmentStatus: text("employment_status").default('active'),
	qualification: text().notNull(),
	specialization: text(),
	experience: integer().default(0).notNull(),
	certifications: text().array(),
	subjects: text().array(),
	role: text().notNull(),
	permissions: jsonb(),
	accessLevel: integer("access_level").default(1),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	unique("staff_staff_id_unique").on(table.staffId),
	unique("staff_email_unique").on(table.email),
]);

export const registeredStudents = pgTable("registered_students", {
	id: serial().primaryKey().notNull(),
	surname: text().notNull(),
	name: text().notNull(),
	preferredName: text(),
	dateOfBirth: text("date_of_birth").notNull(),
	idNumber: text("id_number"),
	sex: text(),
	religion: text(),
	numberOfChildrenInFamily: integer("number_of_children_in_family"),
	positionInFamily: integer("position_in_family"),
	authorizedToBring: text("authorized_to_bring").array(),
	authorizedToCollect: text("authorized_to_collect").array(),
	previousSchool: text("previous_school"),
	intendedPrimarySchool: text("intended_primary_school"),
	careRequired: text("care_required"),
	dateOfEnrolment: text("date_of_enrolment").notNull(),
	ageAtEnrolment: integer("age_at_enrolment"),
	emergencyContactFriendName: text("emergency_contact_friend_name"),
	emergencyContactFriendRelationship: text("emergency_contact_friend_relationship"),
	emergencyContactFriendAddress: text("emergency_contact_friend_address"),
	emergencyContactFriendWorkPhone: text("emergency_contact_friend_work_phone"),
	emergencyContactFriendHomePhone: text("emergency_contact_friend_home_phone"),
	emergencyContactFriendCell: text("emergency_contact_friend_cell"),
	emergencyContactKinName: text("emergency_contact_kin_name"),
	emergencyContactKinRelationship: text("emergency_contact_kin_relationship"),
	emergencyContactKinAddress: text("emergency_contact_kin_address"),
	emergencyContactKinWorkPhone: text("emergency_contact_kin_work_phone"),
	emergencyContactKinHomePhone: text("emergency_contact_kin_home_phone"),
	emergencyContactKinCell: text("emergency_contact_kin_cell"),
	transportContact1Name: text("transport_contact_1_name"),
	transportContact1Phone: text("transport_contact_1_phone"),
	transportContact2Name: text("transport_contact_2_name"),
	transportContact2Phone: text("transport_contact_2_phone"),
	transportContact3Name: text("transport_contact_3_name"),
	transportContact3Phone: text("transport_contact_3_phone"),
	specialInstructions: text("special_instructions"),
	medicalConsent1: text("medical_consent_1"),
	medicalConsent1Father: boolean("medical_consent_1_father").default(false),
	medicalConsent1Mother: boolean("medical_consent_1_mother").default(false),
	medicalConsent1Guardian: boolean("medical_consent_1_guardian").default(false),
	medicalConsent2: text("medical_consent_2"),
	medicalConsent2Father: boolean("medical_consent_2_father").default(false),
	medicalConsent2Mother: boolean("medical_consent_2_mother").default(false),
	medicalConsent2Guardian: boolean("medical_consent_2_guardian").default(false),
	maritalStatus: text("marital_status"),
	motherTitle: text("mother_title"),
	motherSurname: text("mother_surname"),
	motherFirstNames: text("mother_first_names"),
	motherIdNumber: text("mother_id_number"),
	motherOccupation: text("mother_occupation"),
	motherEmployer: text("mother_employer"),
	motherWorkPhone: text("mother_work_phone"),
	motherHomePhone: text("mother_home_phone"),
	motherCell: text("mother_cell"),
	motherEmail: text("mother_email"),
	motherHomeAddress: text("mother_home_address"),
	motherWorkAddress: text("mother_work_address"),
	fatherTitle: text("father_title"),
	fatherSurname: text("father_surname"),
	fatherFirstNames: text("father_first_names"),
	fatherIdNumber: text("father_id_number"),
	fatherOccupation: text("father_occupation"),
	fatherEmployer: text("father_employer"),
	fatherWorkPhone: text("father_work_phone"),
	fatherHomePhone: text("father_home_phone"),
	fatherCell: text("father_cell"),
	fatherEmail: text("father_email"),
	fatherHomeAddress: text("father_home_address"),
	fatherPostalAddress: text("father_postal_address"),
	fatherWorkAddress: text("father_work_address"),
	guardianTitle: text("guardian_title"),
	guardianSurname: text("guardian_surname"),
	guardianFirstNames: text("guardian_first_names"),
	guardianIdNumber: text("guardian_id_number"),
	guardianOccupation: text("guardian_occupation"),
	guardianEmployer: text("guardian_employer"),
	guardianWorkPhone: text("guardian_work_phone"),
	guardianHomePhone: text("guardian_home_phone"),
	guardianCell: text("guardian_cell"),
	guardianEmail: text("guardian_email"),
	guardianHomeAddress: text("guardian_home_address"),
	guardianPostalAddress: text("guardian_postal_address"),
	guardianWorkAddress: text("guardian_work_address"),
	financialAgreedTerms: boolean("financial_agreed_terms"),
	financialAgreedLiability: boolean("financial_agreed_liability"),
	financialAgreedCancellation: boolean("financial_agreed_cancellation"),
	motherFinancialSignature: text("mother_financial_signature"),
	motherFinancialDate: text("mother_financial_date"),
	fatherFinancialSignature: text("father_financial_signature"),
	fatherFinancialDate: text("father_financial_date"),
	monthlyAmount: integer("monthly_amount"),
	paymentDate: text("payment_date"),
	popiConsent: boolean("popi_consent").default(false),
	motherPopiSignature: text("mother_popi_signature"),
	motherPopiDate: text("mother_popi_date"),
	fatherPopiSignature: text("father_popi_signature"),
	fatherPopiDate: text("father_popi_date"),
	status: text().default('pending'),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	address: text(),
	email: text(),
	phone: text(),
	familyDoctor: text("family_doctor"),
	doctorPhone: text("doctor_phone"),
	medicalConditions: text("medical_conditions").array(),
	medicalConditionsDetails: text("medical_conditions_details"),
	childhoodSicknesses: text("childhood_sicknesses"),
	lifeThreateningAllergies: text("life_threatening_allergies"),
	otherAllergies: text("other_allergies"),
	regularMedicationsDetails: text("regular_medications_details"),
	majorOperations: text("major_operations"),
	behaviorProblems: text("behavior_problems"),
	speechHearingProblems: text("speech_hearing_problems"),
	birthComplications: text("birth_complications"),
	immunisationUpToDate: boolean("immunisation_up_to_date"),
	familyMedicalHistory: text("family_medical_history"),
	regularMedications: boolean("regular_medications"),
	livesWith: text("lives_with").array(),
	homeLanguage: text("home_language").array(),
}, (table) => [
	index("idx_registered_students_created").using("btree", table.createdAt.asc().nullsLast().op("timestamp_ops")),
	index("idx_registered_students_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_registered_students_surname").using("btree", table.surname.asc().nullsLast().op("text_ops")),
	check("registered_students_surname_not_empty", sql`(surname IS NOT NULL) AND (surname <> ''::text)`),
]);

export const parentStudentRelations = pgTable("parent_student_relations", {
	id: serial().primaryKey().notNull(),
	parentId: integer("parent_id").notNull(),
	studentId: integer("student_id").notNull(),
	relationship: text().notNull(),
	isPrimaryContact: boolean("is_primary_contact").default(false),
	emergencyContact: boolean("emergency_contact").default(false),
	authorizedToPickup: boolean("authorized_to_pickup").default(true),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_parent_student_parent").using("btree", table.parentId.asc().nullsLast().op("int4_ops")),
	index("idx_parent_student_student").using("btree", table.studentId.asc().nullsLast().op("int4_ops")),
	unique("unique_parent_student_relation").on(table.parentId, table.studentId),
]);

export const parents = pgTable("parents", {
	id: serial().primaryKey().notNull(),
	title: text(),
	name: text().notNull(),
	surname: text().notNull(),
	idNumber: text("id_number"),
	dateOfBirth: text("date_of_birth"),
	gender: text(),
	email: text(),
	phone: text().notNull(),
	alternatePhone: text("alternate_phone"),
	homeAddress: text("home_address"),
	postalAddress: text("postal_address"),
	workAddress: text("work_address"),
	occupation: text(),
	employer: text(),
	workPhone: text("work_phone"),
	relationshipToStudent: text("relationship_to_student").notNull(),
	isPrimaryContact: boolean("is_primary_contact").default(false),
	emergencyContact: boolean("emergency_contact").default(false),
	authorizedToPickup: boolean("authorized_to_pickup").default(true),
	responsibleForFees: boolean("responsible_for_fees").default(false),
	feePaymentMethod: text("fee_payment_method"),
	bankAccountDetails: jsonb("bank_account_details"),
	medicalConsent: boolean("medical_consent").default(false),
	status: text().default('active'),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_parents_email").using("btree", table.email.asc().nullsLast().op("text_ops")),
	index("idx_parents_phone").using("btree", table.phone.asc().nullsLast().op("text_ops")),
	index("idx_parents_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_parents_surname").using("btree", table.surname.asc().nullsLast().op("text_ops")),
	unique("parents_id_number_unique").on(table.idNumber),
	check("parents_name_not_empty", sql`(name IS NOT NULL) AND (name <> ''::text)`),
	check("parents_surname_not_empty", sql`(surname IS NOT NULL) AND (surname <> ''::text)`),
]);

export const staffAttendance = pgTable("staff_attendance", {
	id: serial().primaryKey().notNull(),
	staffId: integer("staff_id").notNull(),
	date: text().notNull(),
	status: text().notNull(),
	checkIn: text("check_in"),
	checkOut: text("check_out"),
	notes: text(),
});
